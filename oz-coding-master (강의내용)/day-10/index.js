// *배열
// 배열은 값의 순서가 있는 집합이며, 각 값을 요소라고 부른다.
// 각 요소에는 배열에서 차지하는 위치를 나타내는 숫자인 인덱스가 있다.
// 자바스크립트 배열에는 타입이 없다. 배열 요소는 어떤 타입이든 상관 없으며, 배열 하나에서 여러 타입이 섞여 있어도 괜찮다.
// 배열 요소에 객체나 다른 배열을 써도 상관없으므로 객체로 이루어진 배열이나 배열로 이루어진 배열 같은 복잡한 데이터 구조를 만들 수도 있다.
// 배열의 첫 번째 요소의 인덱스는 1이 아니라 0으로 시작한다.

// 자바스크립트 배열은 동적이다.
// 필요한 만큼 배열의 크기가 커지거나 작아질 수 있고, 배열을 생성할 때 고정된 크기를 선언하거나 크기가 변할 때 배열을 재할당할 필요가 없다.
// 자바스크립트는 성긴 배열(sparse)을 허용한다. 즉 요소의 인덱스가 꼭 이어질 필요가 없고, 그 사이에 값이 없어도

// *1. 배열 생성
// - 배열 리터럴 ([])
// - 이터러블 (반복 가능한 / for of) 객체의 분해 연산자 ... 적용
// - Array() 생성자 써서 만들 수 있다.
// - Array.of() 와 Array.from() 펙토리 메서드

// *1.1 배열 리터럴
// 배열을 만드는 가장 단순한 방법은 배열 리터럴이다.
// 배열 리터럴은 배열 요소를 대괄호 안에서 콤마(,)로 구분한 리스트 형태이다.

let empty = []; // 요소가 없는 배열
let nums = [1, 2, 3, 4, 5]; // 타입이 숫자인 요소가 5개 있는 배열
let mix = [1.1, true, "문자열"]; // 타입이 다른 요소가 3개인 배열

let base = 1024;
let table = [base, base + 1, basse + 2, base + 3];
console.log(table);

// 배열 리터럴 안에 객체 리터럴이나 다른 배열 리터럴을 써도 된다.

let a = [
  [1, { x: 1, y: 2 }],
  [2, { x: 3, y: 4 }],
];

// 배열 리터럴에 콤마(,)를 연속해서 썻는데, 그 사이에 값이 없으면 성긴 배열이 만들어진다.

let b = [, , ,]; // 값을 생략한 위치에 실제로 배열 요소가 존재하지는 않지만, 검색하면 undefined 가 반환된다.
let count = [1, , 3]; // 인덱스 0과 2에는 요소가 있지만, 인덱스 1에는 요소가 없다.
let undefs = [, ,]; // 요소가 없지만 길이가 2인 배열

console.log(b.length); //3
console.log(count.length); //3
console.log(undefs.length); //2

// 요소가 없으면 마지막 칸은 지운다. / 카운트 되지 않는다.

// *1.2 분해 연산자
// 분해 연산자는 ...를 써서 배열 리터럴 안에 다른 배열 요소를 넣을 수 있다.

let c = [1, 2, 3]; 
let d = [0, ...c, 4];

console.log(d); // 0,1,2,3,4

// 분해 연산자 같은 경우에는 배열을 얕게 (shallow) 복사할 때 유용하다.

let original = [1,2,3];
let copy [...original];

console.log("===== 테스트 01 =====")
console.log(original); // [1,2,3]
console.log(copy); // [1,2,3]
console.log(original === copy); // false / 식별자가 다르다 (메모리 주소가 다름)

// *1.3 Array( 인자 ) 생성자
// - 인자 없이 호출
let newArr1 = new Array(); // 요소가 없는 빈 배열을 생성하며, 배열 리터럴 [] 와 동등하다.

// - 배열 길이를 나타내는 숫자 인자를 하나로 호출
let newArr2 = new Array(5); // 지정된 길이를 가진 배열을 생성한다. 배열 요소가 몇 개 인지 미리 알고 있으면 해당 방법을 사용할 수 있다.

// - 배열 요소를 두 개 이상 쓰거나 숫자가 아닌 요소를 하나만 넘겨 호출
let newArr3 = new Array(5,4,3,2,1, "문자열 01", "문자열 02"); // 다음과 같이 사용하면 생성자의 인자가 새 배열의 요소가 된다.

console.log(newArr1); // []
console.log(newArr2); // length : 5 / [emptyx5]
console.log(newArr3); // length : 7 / [5,4,3,2,1, "문자열 01", "문자열 02"]

// *1.4 Array.of()
// Array() 생성자를 숫자 인자 하나만 넘겨 호출하면 길이가 그 숫자인 배열이 생성되는 걸 확인했습니다.
// 숫자 인자가 하나 이상 있으면 이들 각각을 요소로 취급하여 배열을 생성한다.
// 따라서 Array() 생성자로는 숫자 요소가 하나만 있는 배열은 생성할 수 없다.

Array.of(); // []: 인자가 없으므로 빈 배열
Array.of(10); // [10]: 숫자 인자 하나만 있어도 된다.
Array.of(1,2,3); // [1,2,3]

// *1.5 Array.from()
// 이 메서드는 첫 번째 인자로 이터러블(반복 가능한) 객체나 배열 비슷한 객체(유사 배열: 배열처럼 보이지만 객체)
// 해당 객체의 요소로 새 배열을 만들어 변환한다.
// Array.from(iterable)은 분해 연산자를 사용한 [...iterable]과 동등하다.

let copy2 = Array.from(original);
// let copy2 = [...original] 과 같다.

console.log(copy2); // (3) [1,2,3] / 위 original 과 같이 나온다.

// Array.from()이 중요한 이유는 배열이 비슷한 객체(유사 배열)을 진정한 배열로 바꾸는 방법이기 때문.
// 배열 비슷한 객체란 숫자인 length 프로퍼티가 있고, 이름이 정수인 프로퍼티에 값이 저장된 객체를 말한다.

// Array.from()은 선택 사항으로 두 번째 인자를 받는다.
// 두 번쨰 인자로 함수를 전달하면 새 배열을 생성할 때, 소스 객체의 각 요소를 이 함수에 전달하고 반환 값을 배열에 저장한다.

// *배열과 문자열은 가장 광범위하게 쓰이는 내장 이터러블이다. (암기)

let str = "Hello";
let arr = Array.from(str, function (char, index){
  return char+index;
}); // ["H","e","l","l","o"]

console.log("===== Array.from 테스트 =====")
console.log(str); // Hello
console.log(arr); // (5) ["H0","e1","l2","l3","o4"]
