// *함수
// 함수는 한 번 정의하면 몇 번이고 호출할 수 있는 자바스크립트 코드 블록이다.
// 자바스크립트에서 함수는 매개변수화(parameterized)가 된다.
// 함수 정의에는 매개변수 (parameter)라고 불리는 식별자 리스트가 있는데, 이들은 함수 바디에서 로컬 변수처럼 동작한다.

function fn(parameter) {
  // parameter: 로컬 변수 => 함수 바디에서만 사용할 수 있다.
}

//* console.log(parameter); // TypeError

// 함수를 호출할 때는 매개변수에 값을 전달하는데 이를 인자(argument)라고 한다.

// *1. 함수 정의
// 자바스크립트에서 함수를 정의하는 가장 단순한 방법은 function 키워드이다.
// 이 키워드(function)는 선언으로도, 표현식으로도 사용할 수 있다.

// *2. 함수 선언
// 함수 선언 function 키워드 뒤에 다음 세 가지 구성 요소를 쓴다.
// - 함수 이름이 될 식별자, 이름은 함수 선언에서 뺄 수 없는 부분이다.
// 이 이름은 변수 이름으로 쓰이며, 새로 정의된 함수 객체가 이 변수에 할당 된다.

// - 소괄호로 감싸고 콤마로 구분한 0개 이상의 식별자 리스트.
// 이 식별자들은 함수 매개변수 이름이며, 함수 바디 안에서 로컬 변수로 동작한다.

// - 중괄호로 감싼 0개 이상의 자바스크립트 문.
// 이 문이 함수 바디이며, 함수를 호출할 때마다 실행된다.

// 팩토리얼을 계산하는 재귀함수(자신을 호출하는 함수)
// x!는 x이하의 양의 정수를 모두 곱한 값이다.

console.log(factorial(3)); // 정의 위에 값이 출력되는 이유는 함수 선언문이 호이스팅 되기 때문이다.

function factorial(x) {
  // 팩토리얼을 계산하는 재귀함수 로직을 작성한다.
  if (x <= 1) return 1;
  return x * factorial(x - 1);
}

//* console.log(x); // Error

// 함수 선언에서 이해해야 할 중요한 점은 함수의 이름이 변수이며, 그 값은 함수 자체라는 점이다.
// 함수 선언문은 자신을 포함하는 스크립트, 함수,
// 또는 블록 맨 위에 끌어 올려지므로 함수 선언문으로 정의한 함수는 정의하기 전에도 호출할 수 있다. => 호이스팅

factorial(100); // 매개변수

console.log(factorial(3)); // 6  / 3은 x에 들어가서 함수 적용 ( 3 * 2 * 1 )

//* 2.1 함수 선언문(Declaration)
// 함수 이름이 필수이기 때문에 익명이 불가하다.
function fn() {}

function some(a, b) {
  return a + b;
}
console.log(sum(1, 2)); // 3
console.log(sum(10, 20)); // 30

// 2.2 함수 표현식(Expresstion)
// 함수 표현식은 함수 선언과 거의 비슷하지만,
// 더 큰 표현식이나 문의 일부로서 존재하고 이름을 붙이지 않아도 된다는 점이 함수 선언문과 다르다.
// => 함수 자체가 독립적인 명령이 아니라, 어떤 값으로 취급되어 더 큰 구조물의 일부로 사용될 수 있다는 의미이다.
// => 변수에 할당: const myFunction = function(){...}
// => 콜백 함수: array.map(function(item or element){...})
// => 즉시 실행 함수: (fucntion(){...})()

function fn() {}
const fn = function () {};

// 함수를 변수에 할당했다.
const square = function (x) {
  return x * x;
};

// 표현식으로 정의한 함수에 이름을 붙이는 것은 선택 사항이다. (보통 안붙힌다)
// 함수 선은은 실제로 변수를 선언하며, 그 변수에 함수 객체를 할당한다.
// 함수 표현식은 반드시 변수에 할당해야 하는 것은 아니다.

// 다만, 함수 객체를 나중에 다시 참조해야 한다면, 프로그래머의 선택에 따라 변수 또는 상수에 할당한다.
// 함수 표현식을 쓸 때는 실수로 함수를 덮어쓰지 않도록 하기 위해 const를 사용하는 것이 좋은 습관이다.

// 함수 표현식을 다른 함수의 인자로 사용할 수 있다.
// 이름이 없는 익명함수
[3, 2, 1].sort(function (a, b) {
  return a - b;
});

// 이름 있는 함수로도 가능하지만,
function compareNumbers(a, b) {
  return a - b;
}
[3, 2, 1].sort(compareNumbers);

// 위처럼 작성하려면, compareNumbers라는 이름을 따로 선언해야 한다.
// 하지만 한 번 쓰고 말거라면 굳이 이름을 붙일(함수 선언문) 필요 없이 표현식으로 바로 전달하는게 더 간결하다.

// *2.3 화살표 함수 () => {}
// 화살표 함수는 문이 아니라 표현식이므로 function 키워드는 사용하지 않으며 함수 이름도 필요 없다.
// 화살표 함수의 일반적인 형태는 괄호 안에 콤마로 구분한 매개변수 리스트를 쓰고,
// 그 뒤에 => 화살표와 중괄호로 감싼 함수 바디를 쓰는 형태이다

// - function 키워드를 사용하지 않는다.
// - return 키워드로 로직이 바로 시작되는 경우에는 return 키워드와 중괄호를 제거하여 사용할 수 있다.
// - 매개변수를 가질 수 있는데, 만약 매개변수가 단 한개만 있다고 한다면, 매개 변수를 감싸고 있는 소괄호를 생략할 수 있다.

const sum2 = (a, b) => {
  return a + b;
};
const sum3 = function (a, b) {
  return a + b;
};
const sum4 = (a, b) => a + b;

// 위 세가지는 같은 의미이다.
// 콘솔로그에 포함되어있는 경우, 로직이 return 으로 바로 시작하지 않기에, 생략 불가능하다.
// 리턴 뒤에 위치한 로직은 작동하지 않음.

const getObj = () => {
  return { value: "객체 데이터" };
};

console.log(getObj()); // 함수를 실행할때는 반드시 소괄호를 붙힌다.

const getTest = () => {
  vlaue: "객체 데이터";
}; // 중괄호로 사용된 부분이 마치 함수의 불록처럼 보이기 때문에,자바스크립트 문법적으로 이해할 수 없는 코드로 인해 오류가 발생한다.

console.log(getTest()); // undefined

// 위 문제를 해결하기 위해 객체 데이터는 소괄호로 묶어준다.
// 화살표 함수에서 반환값이 객체 리터럴일 때, 이를 소괄호 ()로 감싸주는 이유는 자바스크립트 문법이 함수 본문 블록{} 객체 리터럴 {}을 혼동하기 때문.
// 화살표 함수의 간결한 문법 (=>)을 사용할때, 개발자가 의도하는 바에 따라 중괄호 {}의 의미가 달라진다.

const getObj2 = () => ({ value: "객체 데이터" });
// 객체 리터럴{ vale : "객체데이터" } 전체를 소괄호 ()로 감싸는 것은 이를 하나의 "표현식"임을 명시적으로 알려준다.
// 소괄호 ()는 => 뒤에 오는 코드가 함수 본문 블록(body block)이 아니라, 즉시 반환해야 할 표현식(Expression)임을 선언한다.
console.log(getObj2()); // { value : "객체 데이터" }

const getArr = () => {
  return [10, 20, 30];
};

console.log(getArr()); // [10,20,30]

const getArr2 = () => [10, 20, 30];
console.log(getArr2()); // [10,20,30]
